#h ARCESS notes

-- 2020-06-13 new better generated SQL for marks

   - sort tree
   - checkbox NOT and OnlyMainSQL
   - trim sqlmain and extraSQL before store them
   - new SQL generation

--- New SQL generation

See exemplox.gast, similar to this one

      LSX, SQL_GEN, UNION, IN
      
      <SQL_GEN>
         // SELECT rowid,
         //        CASE  WHEN @<COND1> THEN "c1 AAA"
         //              WHEN @<COND2> THEN "c2 BBB"
         //              WHEN @<COND3> THEN "c3 CCC"
         //              ELSE "c? ---"
         //        END AS condi,
         //        desc
         // FROM tlog
         // WHERE rowid @<p2> (
         //       SELECT rowid FROM (@<SQLC1>)
         //       @<p1>
         //       SELECT rowid FROM (@<SQLC2>)
         //       @<p1>
         //       SELECT rowid FROM (@<SQLC3>)
         //    )
         // ORDER BY rowid


-- 2020-06-10 improve Dialog for Marks

      - Dialog side aligned
      - check box instead of button
      - mark remove button
      - mark UNION INSTERSECTION check box
      - mark MARK column check box


-- 2020-06-09 New Dialog for Marks

First and simple implementation (script of 75 lines!) of marked lines in a database

      gasti\markselector.gast

--- Purpose for Mark Dialog

A mark is associated with a SELECT query from a table and optional filters.

Technically can be seen as a SQL view but we add some ease on

      - creating it almost on the fly
      - we can associate not only a name but also a tree node, so it can be classified easily
      - recall it with a click
      - merge any combination of compatible marks

This last feature was actually the goal for creating the Mark dialog in Arces.

With this functionality we can create different filters marks on the same table and then
view the result using any combination of them.

A very clear use-case is when the table content is a log or a trace, so we can have marks for
different specific events in the trace and combine them depending on what we want to analyze.

--- Information in a Mark

We store all marks in the same database in the table

      table thisdb_TableMarks (node, markname, mainselect, extrawhere)

where

      node       : is a text representing a tree node separated by / and can be used to classify the mark
      markname   : name for the mark, combined with the node is unique in the table
      mainselect : is the main select and it is taken from the SQL select entry in Arces
      extrawhere : a string containg the WHERE condition generated by Arces main assist grid


--- GUI in Mark Dialog

If we open the Mark dialog we find a tree with all stored "marks"

On selecting one mark the SELECT query with its filters is opened in the main Arcess grid

Additionally a list of all marks which are "compatible" (based on the same main SELECT) are shown

This list accepts multi selection and by doing so a new SELECT is generated combining all marks
in a way that

      - A new column called MARK is added and has the value of the mark the record belongs (*)

      - If a record matches different marks it is shown only once

      - Whereas each mark may have an order associated, when shown in combination
        all records are sorted by the rowid of the table

--- Some minor bugs and things to improve

---- Tricky SELECT for the mark combination

When combining marks we have to use rowid which is a unique id in most sqlite3 tables and always
present if no integer unique key is defined.

And this is for two reasons: sorting and avoiding repetition of records.

We also want to create a new column with the markname value for each mark.

In order to do these two additions we modify the query as follows

      original mark  :  SELECT xxx, yyy FROM ttt
      new query mark :  SELECT rowid, "mymarkname" AS MARK, xxx, yyy FROM ttt

while for the insertion of the markname we could use a technique like

      SELECT "mymarkname" AS MARK, * FROM  (SELECT xxx, yyy FROM ttt)

this would not work for rowid because this column has to be obtained from the original table (e.g. ttt)

So we have to perform an injection which only will work if our base select is based on a table or a query
having rowid as column.

This is the script piece that perform the injection

         <SQL_MARKS>
            //SELECT DISTINCT rowid, * FROM (
            LOOP, VAR, iMarkCompat subTableSelection
                , LINK, " UNION "
                ,, //@<JS-NEWSELECT> @<extrawhere>
            //) ORDER BY rowid

         <JS-NEWSELECT>
            JS, //"@<:encode-strjs mainselect>".replace ("SELECT ", "SELECT rowid, '@<markname>' AS MARK,")
